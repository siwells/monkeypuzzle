/*
 * MarkingDialog.java
 *
 * Created on 05 March 2004, 15:25
 */

/**
 *
 * @author  growe
 */
import java.awt.event.*;
import java.io.*;
import javax.swing.*;
import org.xml.sax.*;
import org.xml.sax.helpers.*; 
import java.util.*;
import java.text.*;

public class MarkingDialog extends javax.swing.JDialog {
  JFileChooser xmlChoice;
  File lastDirectory;
  public Argument tutorArg, studentArg;
  Vector tutorTrav, studentTrav;
  
  /** Creates new form MarkingDialog */
  public MarkingDialog(java.awt.Frame parent, boolean modal) {
    super(parent, modal);
    initComponents();
    ExtensionFileFilter xmlFilter = new ExtensionFileFilter();
    xmlFilter.addExtension("aml");
    xmlChoice = new JFileChooser();
    xmlChoice.setFileFilter(xmlFilter);
  }
  
  /**
   * Constructor for command line marking
   */
  public MarkingDialog()
  {
    
  }
  
  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents()//GEN-BEGIN:initComponents
  {
    java.awt.GridBagConstraints gridBagConstraints;

    fileButtonPanel = new javax.swing.JPanel();
    tutorButton = new javax.swing.JButton();
    studentButton = new javax.swing.JButton();
    markButton = new javax.swing.JButton();
    tutorFileLabel = new javax.swing.JLabel();
    studentFileLabel = new javax.swing.JLabel();
    resultsScrollPane = new javax.swing.JScrollPane();
    resultsTextArea = new javax.swing.JTextArea();
    closePanel = new javax.swing.JPanel();
    closeButton = new javax.swing.JButton();

    setTitle("Mark student's diagram");
    addWindowListener(new java.awt.event.WindowAdapter()
    {
      public void windowClosing(java.awt.event.WindowEvent evt)
      {
        closeDialog(evt);
      }
    });

    fileButtonPanel.setLayout(new java.awt.GridBagLayout());

    tutorButton.setText("Tutor");
    tutorButton.setToolTipText("Load the tutor's solution");
    tutorButton.addActionListener(new java.awt.event.ActionListener()
    {
      public void actionPerformed(java.awt.event.ActionEvent evt)
      {
        tutorButtonActionPerformed(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    fileButtonPanel.add(tutorButton, gridBagConstraints);

    studentButton.setText("Student");
    studentButton.setToolTipText("Load the student's solution");
    studentButton.addActionListener(new java.awt.event.ActionListener()
    {
      public void actionPerformed(java.awt.event.ActionEvent evt)
      {
        studentButtonActionPerformed(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    fileButtonPanel.add(studentButton, gridBagConstraints);

    markButton.setText("Mark");
    markButton.setToolTipText("Mark student's diagram");
    markButton.setEnabled(false);
    markButton.addActionListener(new java.awt.event.ActionListener()
    {
      public void actionPerformed(java.awt.event.ActionEvent evt)
      {
        markButtonActionPerformed(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.weighty = 1.0;
    fileButtonPanel.add(markButton, gridBagConstraints);

    tutorFileLabel.setText("Tutor file: (not loaded)");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.weighty = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    fileButtonPanel.add(tutorFileLabel, gridBagConstraints);

    studentFileLabel.setText("Student file: (not loaded)");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.weighty = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    fileButtonPanel.add(studentFileLabel, gridBagConstraints);

    getContentPane().add(fileButtonPanel, java.awt.BorderLayout.NORTH);

    resultsTextArea.setEditable(false);
    resultsTextArea.setToolTipText("Display results of marking");
    resultsScrollPane.setViewportView(resultsTextArea);

    getContentPane().add(resultsScrollPane, java.awt.BorderLayout.CENTER);

    closeButton.setText("Close");
    closeButton.setToolTipText("Close the dialog");
    closeButton.addActionListener(new java.awt.event.ActionListener()
    {
      public void actionPerformed(java.awt.event.ActionEvent evt)
      {
        closeButtonActionPerformed(evt);
      }
    });

    closePanel.add(closeButton);

    getContentPane().add(closePanel, java.awt.BorderLayout.SOUTH);

    java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
    setBounds((screenSize.width-550)/2, (screenSize.height-300)/2, 550, 300);
  }//GEN-END:initComponents

  private void markButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_markButtonActionPerformed
    resultsTextArea.setText(buildPremiseTable());
  }//GEN-LAST:event_markButtonActionPerformed

  public String buildPremiseTable()
  {
    Tree studentTree = studentArg.getTree();
    Tree tutorTree = tutorArg.getTree();
    TreeVertex root = (TreeVertex)tutorTree.getRoots().elementAt(0);
    tutorTrav = tutorArg.getTree().breadthFirstTraversal(root);
    root = (TreeVertex)studentTree.getRoots().elementAt(0);
    studentTrav = studentArg.getTree().breadthFirstTraversal(root);
    for (int i = 0; i < studentTrav.size(); i++)
    {
      TreeVertex studentVertex = (TreeVertex)studentTrav.elementAt(i);
      studentVertex.clearTutorParameters();
    }
    // For each tutor vertex, try to find a matching student vertex
    for (int i = 0; i < tutorTrav.size(); i++)
    {
      TreeVertex tutorVertex = (TreeVertex)tutorTrav.elementAt(i);
      tutorVertex.clearTutorParameters();
      TreeVertex testTutorVertex;
      // If tutorVertex is virtual, we use the properties of its parent.
      // This is necessary since virtual nodes don't have any text associated
      // with them, so we can't compare them directly
      if (tutorVertex.isVirtual())
      {
        testTutorVertex = tutorVertex.getParent();
      } else {
        testTutorVertex = tutorVertex;
      }
      int tutorStart = testTutorVertex.getTutorStart();
      int tutorEnd = testTutorVertex.getTutorEnd();
      int tutorOffset = testTutorVertex.getOffset();
      String tutorText = testTutorVertex.getLabel().toString();
      // If start & end markers are both 0, means that no flexible endpoints
      // have been defined for this vertex, so just use exact selected text
      if (tutorStart == 0 && tutorEnd == 0)
      {
        tutorStart = tutorOffset;
        tutorEnd = tutorStart + tutorText.length();
      }
      // The range of acceptable endpoints in student vertex is between tutorStart and tutorEnd
      for (int s = 0; s < studentTrav.size(); s++)
      {
        TreeVertex studentVertex = (TreeVertex)studentTrav.elementAt(s);
        TreeVertex testStudentVertex;
        if (studentVertex.isVirtual())
        {
          testStudentVertex = studentVertex.getParent();
        } else {
          testStudentVertex = studentVertex;
        }
        int studentOffset = testStudentVertex.getOffset();
        String studentText = testStudentVertex.getLabel().toString();
        if (studentOffset >= tutorStart && studentOffset <= tutorOffset &&
          studentOffset + studentText.length() >= tutorOffset + tutorText.length() &&
          studentOffset + studentText.length() <= tutorEnd &&
          studentVertex.isVirtual() == tutorVertex.isVirtual())
        {
          // If the matching vertices are not virtual, map them onto each other
          if (!studentVertex.isVirtual())
          {
            studentVertex.tutorLink = tutorVertex;
            tutorVertex.studentLink = studentVertex;
            // Otherwise if they are virtual, add the student virtual vertex to
            // the tutor virtual vertex's parent's list of virtual vertices to check.
            // This allows for the parent having more than one virtual child.
          } else {
            tutorVertex.getParent().studentVirtualList.add(studentVertex);
          }
          /*
          System.out.println("Matched student " + studentOffset + " to " + tutorStart + " - " + tutorOffset +
            " end... " + (studentOffset + studentText.length()) + " to " + 
            (tutorOffset + tutorText.length()) + " - " + tutorEnd);*/
        }
      }
    }
    
    // Display results
    String summary = "";
    String premiseId = "PREMISE IDENTIFICATION\r\n";
    int premiseCount = 0, premiseMatch = 0;
    for (int i = 0; i < tutorTrav.size(); i++)
    {
       TreeVertex tutorVertex = (TreeVertex)tutorTrav.elementAt(i);
       TreeVertex student = tutorVertex.studentLink;
       if (!tutorVertex.isVirtual())
       {
         premiseCount ++;
       }
       if (student == null)
       {
         premiseId += "No match found for tutor vertex " + tutorVertex.getShortLabelString() + "\r\n";
       } else {
         premiseId += "Tutor vertex " + tutorVertex.getShortLabelString() + " matched with student vertex " +
           student.getShortLabelString() + "\r\n";
         premiseMatch ++;
       }
    }
    DecimalFormat formatter = new DecimalFormat("##.##");
    summary += "Premises: " + formatter.format(100*(float)premiseMatch / premiseCount);
    premiseId += "=====================================\r\n";
    premiseId += "COMPARING TUTOR AND STUDENT DIAGRAMS\r\n";
     
    premiseId += compareTrees();
    summary += "; Vertex matches: " + formatter.format(100*(float)vertexMatch / vertexCount);
    if (matchFound)
    {
      premiseId += "\r\nTUTOR AND STUDENT TREES MATCH\r\n";
    } else {
      premiseId += "\r\nTUTOR AND STUDENT TREES DO NOT MATCH\r\n";
    }
    return summary;
  }
  
  /**
   * Compares the vertexes in the tutor's and student's diagrams.
   * For each vertex in the tutor's diagram, the corresponding vertex in the student's
   * diagram is found (if there is one). The children of the tutor and student vertexes
   * are then compared to see if they are the same.
   */
  boolean matchFound;
  int vertexCount, vertexMatch;
  private String compareTrees()
  {
    vertexCount = 0;
    vertexMatch = 0;
    String compareString = "";
    matchFound = true;
    for (int i = 0; i < tutorTrav.size(); i++)
    {
       TreeVertex tutorVertex = (TreeVertex)tutorTrav.elementAt(i);
       TreeVertex studentVertex = tutorVertex.studentLink;
       vertexCount ++;
       // If it's not a virtual vertex...
       if (!tutorVertex.isVirtual())
       {
         if (studentVertex == null)
         {
           compareString += tutorVertex.getShortLabelString() + " not matched in student diagram.\r\n";
           matchFound = false;
           continue;
         }
         compareString += tutorVertex.getShortLabelString() + "  matched by " +
          studentVertex.getShortLabelString() + " in student diagram.\r\n";
         if (!compareVertices(tutorVertex, studentVertex))
         {
           compareString += "Children of " + tutorVertex.getShortLabelString() + 
            " in tutor diagram do not match those of " +
            studentVertex.getShortLabelString() + " in student diagram.\r\n";
           matchFound = false;
         } else {
           vertexMatch ++;
         }
         // Otherwise we need to compare the tutorVertex with each of the virtual
         // student vertices stored in tutorVertex's parent's studentVirtualList
       } else {
         Vector tutorParentList = tutorVertex.getParent().studentVirtualList;
         boolean virtualMatchFound = false;
         for (int v = 0; v < tutorParentList.size(); v++)
         {
           if(compareVertices(tutorVertex, (TreeVertex)tutorParentList.elementAt(v)))
           {
             virtualMatchFound = true;
           }
         }
         if (!virtualMatchFound)
         {
           compareString += "Linked argument child of " + tutorVertex.getParent().getShortLabelString() +
            " has no match in student diagram.\r\n";
           matchFound = false;
         } else {
           vertexMatch ++;
         }
       }
    }
    return compareString;
  }
  
  private boolean compareVertices(TreeVertex tutorVertex, TreeVertex studentVertex)
  {
    int tutorChildren = tutorVertex.getNumberOfChildren();
    int studentChildren = studentVertex.getNumberOfChildren();
    if (tutorChildren != studentChildren)
    {
      matchFound = false;
      return false;
    }
    Vector tutorEdges = tutorVertex.getEdgeList();
    Vector studentEdges = studentVertex.getEdgeList();
    // For each child of tutorVertex, see if its studentLink vertex is also a child of studentVertex
    int numTutorVerticesTested = 0;
    for (int j = 0; j < tutorChildren; j++)
    {
     TreeEdge edge = (TreeEdge)tutorEdges.elementAt(j);
     TreeVertex child = edge.getDestVertex();
     if (child.isVirtual()) continue;
     numTutorVerticesTested++;
     boolean childMatched = false;
     for (int k = 0; k < studentChildren; k++)
     {
       TreeEdge studentEdge = (TreeEdge)studentEdges.elementAt(k);
       TreeVertex studentChild = studentEdge.getDestVertex();
       if (studentChild == child.studentLink)
       {
         childMatched = true;
         return true;
       }
     }
     if (!childMatched)
     {
       matchFound = false;
       return false;
     }
    }
    // If no tutor vertices tested, all children of tutorVertex are virtual
    // so provided the number of children match, return true
    if (numTutorVerticesTested == 0)
      return true;
    return false;
  }
  
  private void closeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButtonActionPerformed
    setVisible(false);
  }//GEN-LAST:event_closeButtonActionPerformed

  private void studentButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_studentButtonActionPerformed
    studentArg = new Argument();
    readXML(studentArg, "Student file: ", studentFileLabel);
    if (studentArg != null && tutorArg != null)
    {
      markButton.setEnabled(true);
    } else {
      markButton.setEnabled(false);
    }
  }//GEN-LAST:event_studentButtonActionPerformed

  private void tutorButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_tutorButtonActionPerformed
    tutorArg = new Argument();
    readXML(tutorArg, "Tutor file: ", tutorFileLabel);
    if (studentArg != null && tutorArg != null)
    {
      markButton.setEnabled(true);
    } else {
      markButton.setEnabled(false);
    }
  }//GEN-LAST:event_tutorButtonActionPerformed
  
  /** Closes the dialog */
  private void closeDialog(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_closeDialog
    setVisible(false);
    dispose();
  }//GEN-LAST:event_closeDialog

  public void readXML(Argument arg, String labelPrefix, JLabel label)
  {
    File saveDirectory = null;
    String fileName = "";
    File chosenFile = null;
    try {
      xmlChoice.setDialogTitle("Open argument");
      // Sets directory to amlDirectory specified in preferences
      xmlChoice.setCurrentDirectory(new File(Araucaria.amlDirectory));
      if (xmlChoice.showOpenDialog(null) !=
          JFileChooser.APPROVE_OPTION)	{
            return;
      }
      lastDirectory = xmlChoice.getCurrentDirectory();
      chosenFile = xmlChoice.getSelectedFile();
      // See if user has typed in the .aml suffix. If not, add it.
      if (chosenFile.getPath().indexOf(".aml") == -1) {
        String newPath = chosenFile.getPath() + ".aml";
        chosenFile = new File(newPath);
      }
      if (!chosenFile.exists()) {
        // Add a JOptionPane here
        return;
      }
      fileName = chosenFile.getAbsolutePath();
      label.setText(labelPrefix + fileName);
    } catch (Exception e) {  
    }
    String result = processFile(arg, chosenFile);
    if (!result.equals("OK"))
    {
      resultsTextArea.setText(result);
    }
  }
  
  public String processFile(Argument arg, File chosenFile)
  {
    String fileName = chosenFile.getAbsolutePath();
    try {
      arg.emptyTree(true);
      // Try using SAX to parse the XML file
      FileInputStream fileStream = new FileInputStream(fileName);
      char inBuffer[] = new char[(int)chosenFile.length()];
      
      InputStreamReader isReader = new InputStreamReader(fileStream, "UTF-8");
      BufferedReader r = new BufferedReader(isReader);
      int charsRead = r.read(inBuffer, 0, inBuffer.length);
      String text = new String(inBuffer);
      text = text.substring(0, charsRead);
      inBuffer = text.toCharArray();
      CharArrayReader charReader = new CharArrayReader(inBuffer);
      fileStream.close();
      
      InputSource saxInput = new InputSource(charReader);
      parseXMLwithSAX(saxInput, arg.getTree());
    } catch (IOException e) {
      return "Error reading URI: " + e.getMessage();
    } catch (SAXException e) {
      e.printStackTrace();
      return "Error in parsing " + fileName + ": " + e.getMessage();
    } catch (Exception e)  {
      return "Error: " + fileName;
    } catch (Error e) {
      return "Error: " + fileName;
    }
    return "OK";
  }
  
  /**
   * This version uses a TutorContentHandler
   * to do the parsing. This builds the tree & text but ignores all graphics.
   */
  public void parseXMLwithSAX(InputSource source, Tree tree) throws Exception {
      org.xml.sax.ContentHandler contentHandler = 
        new TutorContentHandler(tree);
      org.xml.sax.ErrorHandler errorHandler = new XMLErrorHandler();        
      XMLReader parser = 
          XMLReaderFactory.createXMLReader();
      //"org.apache.xerces.parsers.SAXParser");
      parser.setContentHandler(contentHandler);
      parser.setErrorHandler(errorHandler);  
      parser.setFeature("http://xml.org/sax/features/validation", true);           
      parser.setFeature("http://xml.org/sax/features/namespaces", false);                     
      parser.parse(source);
  }

  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton closeButton;
  private javax.swing.JPanel closePanel;
  private javax.swing.JPanel fileButtonPanel;
  private javax.swing.JButton markButton;
  private javax.swing.JScrollPane resultsScrollPane;
  private javax.swing.JTextArea resultsTextArea;
  private javax.swing.JButton studentButton;
  private javax.swing.JLabel studentFileLabel;
  private javax.swing.JButton tutorButton;
  private javax.swing.JLabel tutorFileLabel;
  // End of variables declaration//GEN-END:variables
  
}
